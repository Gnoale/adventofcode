#!/usr/bin/env python

import os

path = os.path.abspath('.') 

class Intcode():

    def __init__(self, data, start=None):
        self.run = data.copy()  # the intcode list
        self.start = start      # the first parameter
        self.diag = 0           # used to return output value
        self.phase = None
        self.pointer = 0
        self.opcode = None
        self.para1 = None
        self.para2 = None
        self.mode1 = None
        self.mode2 = None

    def setOpmode(self):
        # Instructions are potentially 5 digits integers (10000)
        # Opcode is 2 last digits (DE)
        # Mode1 (C) and Mode2 (B) are either 0 or 1, respectfully 3rd and 4th digits
        # Example
        # ABCDE
        #  1002
        opcodes = {
            1:"add",
            2:"mult",
            3:"store",
            4:"diag",
            5:"jumpt",
            6:"jumpf",
            7:"less",
            8:"equal",
            99:"exit"
        }
        #print(self.pointer)
        self.opcode = opcodes[self.run[self.pointer]%100]
        self.mode1 = self.run[self.pointer]%1000//100
        self.mode2 = self.run[self.pointer]//1000
        # Mode 3 is not implemented yet

    def setParameters(self):
        if self.mode1 == 0:
            self.para1 = self.run[self.run[self.pointer+1]]
        elif self.mode1 == 1:
            self.para1 = self.run[self.pointer+1]
        if self.mode2 == 0:
            self.para2 = self.run[self.run[self.pointer+2]]
        elif self.mode2 == 1:
            self.para2 = self.run[self.pointer+2]

    def opAdd(self):
        self.run[self.run[self.pointer+3]] = self.para1 + self.para2
        self.pointer += 4

    def opMult(self):
        self.run[self.run[self.pointer+3]] = self.para1 * self.para2
        self.pointer += 4

    # first (and second) instruction 
    #Â if the phase parameter is defined and the program just started we must use its value first
    # then the value use will be either 0 if running on the first "amplifier"
    # or equal to the latest output value
    def opStore(self, output):
        if self.phase is None:
            self.run[self.run[self.pointer+1]] = self.start
        elif self.pointer == 0:
            self.run[self.run[self.pointer+1]] = self.phase
        else:
            self.run[self.run[self.pointer+1]] = output
        self.pointer += 2

    def opDiag(self):
        self.diag = self.run[self.run[self.pointer+1]]
        print("Diagnostic Code", self.diag)
        self.pointer += 2

    def opJumpf(self):
        if self.para1 == 0:
            self.pointer = self.para2
        else:
            self.pointer += 3

    def opJumpt(self):
        if self.para1 != 0:
            self.pointer = self.para2
        else:
            self.pointer += 3
    
    def opLess(self):
        if self.para1 < self.para2:
            self.run[self.run[self.pointer+3]] = 1
        else:
            self.run[self.run[self.pointer+3]] = 0
        self.pointer += 4  

    def opEqual(self):
        if self.para1 == self.para2:
            self.run[self.run[self.pointer+3]] = 1
        else:
            self.run[self.run[self.pointer+3]] = 0
        self.pointer += 4

    # run the intcode
    def opRun(self, output=0):
        # These case doesn't use the parameters retrieval
        nopara = ["store", "diag", "exit"]
        while self.pointer < len(self.run):
            self.setOpmode()
            print(self.pointer, self.opcode)
            # Avoid list index out of range exception
            if self.opcode not in nopara:
                self.setParameters()
            if self.opcode == "add":
                self.opAdd()
            elif self.opcode == "mult":
                self.opMult()
            elif self.opcode == "store":
                if self.phase is None:
                    self.opStore()
                else:
                    self.opStore(output)
            elif self.opcode == "diag":
                self.opDiag()
            elif self.opcode == "jumpt":
                self.opJumpt()
            elif self.opcode == "jumpf":
                self.opJumpf()
            elif self.opcode == "less":
                self.opLess()
            elif self.opcode == "equal":
                self.opEqual()
            elif self.opcode == "exit":
                print(self.run)
                print()
                # output value
                return self.diag


if __name__=='__main__':
    
    data = []
    with open(path+'/input', 'r') as f:
        for l in f:
            for i in l.split(','):
                data.append(int(i))

    #data = [3,15,3,16,1002,16,10,16,1,16,15,15,4,15,99,0,0]
#    data = [3,31,3,32,1002,32,10,32,1001,31,-2,31,1007,31,0,33,
#1002,33,7,33,1,33,31,31,1,32,31,31,4,31,99,0,0,0]
    # 120 possibility N!
    phases = [0,1,2,3,4] 
    N = len(phases)

    from itertools import permutations

#    intcode = Intcode(data,5)
#    print(data)
#    intcode.opRun()

    m = {}

    for permut in permutations(phases):
        # (3, 1, 4, 2, 0)
        # (3, 2, 0, 4, 1)
        # ...
        # first element handled separetly (default output value to 0)
        worker = Intcode(data)
        print(worker.run, permut[0], repr(worker))
        worker.phase = permut[0]
        output = worker.opRun()
        for p in permut[1:]:
            worker = Intcode(data)
            print(worker.run, p, output, repr(worker))
            worker.phase = p
            output = worker.opRun(output)
        # store current permutation and last oassociated output value 
        m[permut] = output
    
    maximum = 0
    permut = ()

    for k, v in m.items():
        if v > maximum:
            permut = k
            maximum = v
    print(permut, maximum)
